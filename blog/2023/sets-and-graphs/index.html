<!DOCTYPE html> <html> <script>let thunk=()=>{let e=e=>e.trim(),t=e=>e.innerText,n=e=>{let t=e.split(" "),n=t.slice(0,-1).join(" ");return[t.at(-1),n]},a=Array.from(document.getElementsByClassName("author")).map(t).map(e).map(n),i=a[0][0],o=(Array.from(document.getElementsByClassName("affiliation")).filter(e=>"P"===e.nodeName).map(t).map(e),"May 1, 2023"),r="Universality of Neural Networks on Sets vs. Graphs",l="Universal function approximation is one of the central tenets in theoretical deep learning research. It is the question of whether a specific neural network architecture is, in theory, able to approximate any function of interest. The ICLR paper \u201cHow Powerful are Graph Neural Networks?\u201d shows that mathematically analysing the constraints of an architecture as a universal function approximator and alleviating these constraints can lead to more principled architecture choices, performance improvements, and long-term impact on the field. Specifically in the fields of learning on sets and learning on graphs, universal function approximation is a well-studied property. The two fields are closely linked because the need for permutation invariance in both cases leads to similar building blocks. However, we argue that these two fields have sometimes evolved in parallel, not fully exploiting their synergies. This post aims at bringing these two fields closer together, particularly from the perspective of universal function approximation.";{let e=a.map(e=>`${e[0]}, ${e[1]}`).join(" and "),t=`\n@inproceedings{${(i+"2023"+r.split(" ").slice(0,3).join("")).replace(" ","").replace(/[\p{P}$+<=>^`|~]/gu,"").toLowerCase().trim()},\n  author = {${e}},\n  title = {${r}},\n  abstract = {${l}},\n  booktitle = {ICLR Blogposts 2023},\n  year = {2023},\n  date = {${o}},\n  note = {${window.location.href}},\n  url  = {${window.location.href}}\n}\n  `.trim();document.getElementById("bibtex-box").innerText=t}{let e=a.map(e=>e[0]),t=`\n${e=e.length>2?e[0]+", et al.":2==e.length?e[0]+" & "+e[1]:e[0]}, "${r}", ICLR Blogposts, 2023.\n`.trim();document.getElementById("bibtex-academic-attribution").innerText=t}};document.addEventListener("readystatechange",function(){"complete"===document.readyState&&thunk()});</script> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Universality of Neural Networks on Sets vs. Graphs | ICLR Blogposts 2023</title> <meta name="author" content="abc b c"/> <meta name="description" content="Universal function approximation is one of the central tenets in theoretical deep learning research. It is the question of whether a specific neural network architecture is, in theory, able to approximate any function of interest. The ICLR paper “How Powerful are Graph Neural Networks?” shows that mathematically analysing the constraints of an architecture as a universal function approximator and alleviating these constraints can lead to more principled architecture choices, performance improvements, and long-term impact on the field. Specifically in the fields of learning on sets and learning on graphs, universal function approximation is a well-studied property. The two fields are closely linked because the need for permutation invariance in both cases leads to similar building blocks. However, we argue that these two fields have sometimes evolved in parallel, not fully exploiting their synergies. This post aims at bringing these two fields closer together, particularly from the perspective of universal function approximation."/> <meta name="keywords" content="machine-learning, ml, deep-learning, reinforcement-learning, iclr"/> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"/> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"/> <link rel="shortcut icon" href="/2023/assets/img/iclr_favicon.ico"/> <link rel="stylesheet" href="/2023/assets/css/main.css"> <link rel="canonical" href="https://iclr-blogposts.github.io/2023/blog/2023/sets-and-graphs/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"/> <script src="/2023/assets/js/theme.js"></script> <script src="/2023/assets/js/dark_mode.js"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/2023/assets/js/distillpub/template.v2.js"></script> <script src="/2023/assets/js/distillpub/transforms.v2.js"></script> <script src="/2023/assets/js/distillpub/overrides.js"></script> <style type="text/css">.fake-img{background:#bbb;border:1px solid rgba(0,0,0,0.1);box-shadow:0 0 4px rgba(0,0,0,0.1);margin-bottom:12px}.fake-img p{font-family:monospace;color:white;text-align:left;margin:12px 0;text-align:center;font-size:16px}</style> </head> <d-front-matter> <script async type="text/json">{
      "title": "Universality of Neural Networks on Sets vs. Graphs",
      "description": "Universal function approximation is one of the central tenets in theoretical deep learning research. It is the question of whether a specific neural network architecture is, in theory, able to approximate any function of interest. The ICLR paper “How Powerful are Graph Neural Networks?” shows that mathematically analysing the constraints of an architecture as a universal function approximator and alleviating these constraints can lead to more principled architecture choices, performance improvements, and long-term impact on the field. Specifically in the fields of learning on sets and learning on graphs, universal function approximation is a well-studied property. The two fields are closely linked because the need for permutation invariance in both cases leads to similar building blocks. However, we argue that these two fields have sometimes evolved in parallel, not fully exploiting their synergies. This post aims at bringing these two fields closer together, particularly from the perspective of universal function approximation.",
      "published": "May 1, 2023",
      "authors": [
        {
          "author": "Fabian B. Fuchs*",
          "authorURL": "https://fabianfuchsml.github.io",
          "affiliations": [
            {
              "name": "Google DeepMind",
              "url": ""
            }
          ]
        },
        {
          "author": "Petar Veličković*",
          "authorURL": "https://petar-v.com/",
          "affiliations": [
            {
              "name": "(*equal contribution)",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> <body class="fixed-top-nav"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/2023/">ICLR Blogposts 2023</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/2023/about">about</a> </li> <li class="nav-item "> <a class="nav-link" href="/2023/call">call for blogposts</a> </li> <li class="nav-item "> <a class="nav-link" href="/2023/submitting">submitting</a> </li> <li class="nav-item "> <a class="nav-link" href="/2023/reviewing">reviewing</a> </li> <li class="nav-item "> <a class="nav-link" href="/2023/blog/index.html">blog</a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">other iterations</a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item" href="https://iclr-blogposts.github.io/2025/">2025</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="https://iclr-blogposts.github.io/2024/">2024</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="https://iclr-blogposts.github.io/2023/"><strong>2023</strong></a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="https://iclr-blog-track.github.io/home/" target="_blank" rel="noopener noreferrer">2022</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> </header> <div class="post distill"> <d-title> <h1>Universality of Neural Networks on Sets vs. Graphs</h1> <p>Universal function approximation is one of the central tenets in theoretical deep learning research. It is the question of whether a specific neural network architecture is, in theory, able to approximate any function of interest. The ICLR paper “How Powerful are Graph Neural Networks?” shows that mathematically analysing the constraints of an architecture as a universal function approximator and alleviating these constraints can lead to more principled architecture choices, performance improvements, and long-term impact on the field. Specifically in the fields of learning on sets and learning on graphs, universal function approximation is a well-studied property. The two fields are closely linked because the need for permutation invariance in both cases leads to similar building blocks. However, we argue that these two fields have sometimes evolved in parallel, not fully exploiting their synergies. This post aims at bringing these two fields closer together, particularly from the perspective of universal function approximation.</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div><a href="#sets-and-graphs">Sets and Graphs</a></div> <div><a href="#why-do-we-care-about-universal-function-approximation">Why do we care about universal function approximation?</a></div> <div><a href="#learning-on-sets-universality">Learning on Sets &amp; Universality</a></div> <div><a href="#approximation-vs-representation">Approximation vs. Representation</a></div> <div><a href="#what-about-graph-representation-learning">What about _graph_ representation learning?</a></div> <div><a href="#learning-on-graphs-and-universality">Learning on Graphs and Universality</a></div> <div><a href="#the-weisfeiler-lehman-test">The Weisfeiler-Lehman Test</a></div> <div><a href="#broader-context-and-takeaways">Broader Context and Takeaways</a></div> </nav> </d-contents> <h2 id="sets-and-graphs">Sets and Graphs</h2> <p>Before we dive into<d-footnote>It is important to briefly focus on declaring the *conflict of interest* we had while writing this blog. We are actively working on set and graph representation learning. Accordingly, several paragraphs of this write-up focus on papers that we have co-written. That being said, and in the context of ICLR, we declare that the majority of the ICLR papers referenced in this blog post do _not_ present a conflict of interest for us. Hence, we believe we have, to the best of our efforts, provided an objective and impartial view of learning universal representations over graphs and sets.</d-footnote> universal function approximation, let’s start with the basics. What do we mean by learning on set- or graph-based data? In both cases, we assume no ordering (we will more formally describe this at the end of this section as the task being permutation <em>invariant</em> or <em>equivariant</em>). A graph is typically thought of as a set of nodes with edges between the nodes. A set doesn’t have edges, it just has the nodes, although we often don’t call them nodes, but rather set elements. Both the nodes and the edges (in the case of graphs) can have feature vectors attached to them. The figure below (originally from Wagstaff et al. 2021<d-cite key="wagstaff21"></d-cite>) visualises this relationship:</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/2023/assets/img/2023-05-01-sets-and-graphs/graphsuniv_graphsandsets-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/2023/assets/img/2023-05-01-sets-and-graphs/graphsuniv_graphsandsets-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/2023/assets/img/2023-05-01-sets-and-graphs/graphsuniv_graphsandsets-1400.webp"></source> <img src="/2023/assets/img/2023-05-01-sets-and-graphs/graphsuniv_graphsandsets.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>Examples of machine learning tasks on this type of data include 3D point cloud classification (a function mapping a set of coordinates to an object class) and molecular property prediction (a function mapping a molecular graph to, e.g., a free energy value).</p> <p>So, what are invariance and equivariance? Both concepts describe how the output of a function (or task) changes under a transformation of the input. Transformation can mean different things, but we restrict ourselves to permutations here for simplicity. A function \(f\) is permutation <em>invariant</em> if the output does not change as the inputs are permuted. The left-hand side of the following figure below visualises that concept:</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/2023/assets/img/2023-05-01-sets-and-graphs/graphsuniv_permutations-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/2023/assets/img/2023-05-01-sets-and-graphs/graphsuniv_permutations-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/2023/assets/img/2023-05-01-sets-and-graphs/graphsuniv_permutations-1400.webp"></source> <img src="/2023/assets/img/2023-05-01-sets-and-graphs/graphsuniv_permutations.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>The right-hand side depicts permutation <em>equivariance:</em> changing the order of the input implies a change in the order of the output (but the values themselves remain unchanged).</p> <p>Tasks (or functions) defined on sets and graphs are typically permutation invariant or equivariant. This symmetry is often incorporated into the neural network architecture, as we will see in examples below. It is exactly the incorporation of the symmetry that makes the question of universalilty so interesting: is the network (theoretically) able to model all permutation invariant (or equivariant) functions on this data?</p> <h2 id="why-do-we-care-about-universal-function-approximation">Why do we care about universal function approximation?</h2> <p>First of all, why do we need to be able to approximate all functions? After all, having <em>one</em> function that performs well on the train set and generalises to the test set is all we need in most cases. Well, the issue is that we have no idea what such a function looks like, otherwise we would implement it directly and wouldn’t need to train a neural network. Hence, the network not being a universal function approximator <em>may</em> hurt its performance. </p> <p>Graph Isomorphism Networks (GINs) by Xu et al.<d-cite key="GIN"></d-cite>) provide the quintessential example of the merit of universality research. The authors first realised that it is possible to mathematically describe all functions that can be computed by graph neural networks relying on message passing between immediate neighbours, over graphs with discrete-valued features. They then analysed Graph Convolutional Networks (a very popular class of graph neural networks by Kipf and Welling 2016 [3]), and pointed out that GCNs are not capable of expressing all of these functions — that is, they are not universal. Guided by their analysis, the authors then created the GIN, which was provably capable of expressing all possible such functions and achieved significantly better empirical results. </p> <p>However, this is not always the case. Sometimes, architecture changes motivated by universal function approximation arguments lead to <em>worse</em> results. Even in such unfortunate cases, however, we argue that thinking about universality is no waste of time. Firstly, it brings structure into the literature and into the wide range of models available. We need to group approaches together to see the similarities and differences. Universality research can and has served as a helpful tool for that.</p> <p>Moreover, proving that a certain architecture is or is not universal is an inherently interesting task and teaches us mathematical thinking and argumentation. In a deep learning world, where there is a general sense of randomness and magic in building high-performing neural networks and where it’s hard to interpret what’s going on, one might argue that an additional mathematical analysis is probably good for the balance, even if it turns out to not always directly result in better performance.</p> <h2 id="learning-on-sets--universality">Learning on Sets &amp; Universality</h2> <p>To prove universal function approximation<d-footnote>There is actually a nuanced distinction between *approximation* and *representation*, which we will glance over for now but discuss in the next section.</d-footnote>, we typically make two assumptions: 1) the MLP components of the neural networks are arbitrarily large. 2) the functions that we want to be able to learn are continuous on \(\mathbb{R}\). Continuity for a function \(f(x)\) mapping from \(\mathbb{R}\) to \(\mathbb{R}\) implies that for all \(x_0\) in the domain of \(f\) and all \(\epsilon &gt; 0, \epsilon \in R\), there exists a \(\delta &gt; 0, \delta \in R\) such that \(|x - x_0| &lt; \delta\) implies \(|f(x) - &lt; f(x_0)| &lt; \epsilon\) if \(x\) is in the domain of \(f\).</p> <p>The first part says: any concrete implementation of a ‘universal’ network architecture might not be able to learn the function of interest, but, if you make it <a href="https://i.redd.it/n9fgba8b0qr01.png" target="_blank" rel="noopener noreferrer">bigger</a>, eventually it will—and that is <em>guaranteed</em><d-footnote>Conversely, if the network is provably non-universal (like Graph Convolutional Networks), then there are functions it can *never* learn, no matter how many layers you stack.</d-footnote>. The second part is a non-intuitive mathematical technicality we will leave uncommented for now and get back to later (because it’s actually a really interesting and important technicality).</p> <p>One of the seminal papers discussing both permutation invariant neural networks and universal function approximation was Deep Sets by Zaheer et al. in 2017<d-cite key="Zaheer2017"></d-cite>. The idea is simple: apply the same neural network \(\phi\) to several inputs, sum up their results, and apply a final neural network \(\rho\).<d-footnote>Figure from Wagstaff et al. 2021.</d-footnote></p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/2023/assets/img/2023-05-01-sets-and-graphs/graphsuniv_deepsets-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/2023/assets/img/2023-05-01-sets-and-graphs/graphsuniv_deepsets-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/2023/assets/img/2023-05-01-sets-and-graphs/graphsuniv_deepsets-1400.webp"></source> <img src="/2023/assets/img/2023-05-01-sets-and-graphs/graphsuniv_deepsets.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>Because the sum operation is permutation invariant, the final output is invariant with respect to the ordering of the inputs. In other words, the sum quite obviously restricts the space of learnable functions to permutation invariant ones. The question is, can a neural network with this architecture, in principle, learn <em>all</em> (continuous) permutation invariant functions? Perhaps surprisingly, the authors show that all functions can indeed be represented with this architecture. The idea is a form of binary bit-encoding in the output of \(\phi\), which we will call the <em>latent space</em> from here on. Concretely, they argue that there is a bijective mapping from rational to natural numbers. Assuming that each input is a rational number, they first map each rational number \(x\) to a natural number \(c(x)\), and then each natural number to \(\phi(x) = 4^{-c(x)}\). It is now easy to see that \(\sum_i \phi(x_i) \neq \sum_i \phi(y_i)\) unless the finite sets \(\\{ x_0, x_1, ... \\}\) and \(\\{y_0, y_1, ...\\}\) are the same. Now that we uniquely encoded each input, a universal decoder can map this to any output we want. This concludes the proof that the Deep Sets architecture is, in theory, a universal function approximator, despite its simplicity.</p> <p>However, there is an issue with this proof: it builds on the assumption that the MLP components themselves are universal function approximators, in the limit of infinite width. However, the universal function approximation theorem says that this is the case only for continuous functions, where continuity is defined on the real numbers. That continuity is important is sort of intuitive: continuity means that a small change in the input implies a small change in the output. And because the building blocks of neural networks (specifically linear combinations and non-linearities) are continuous, it makes sense that the overall function we want the network to learn should be continuous.</p> <p>But why continuity on the real numbers? Because continuity on the rational numbers is not a very useful property as shown in Wagstaff et al. 2019<d-cite key="wagstaff19"></d-cite>. The mapping we described above is clearly highly discontinuous, and anyone could attest that it is completely unrealistic to assume that a neural network could learn such a function. That doesn’t mean all is lost. Wagstaff et al. show that the Deep Sets architecture is still a universal function approximator when requiring continuity, but only if the latent space (the range of \(\phi\)) has a dimensionality at least as large as the number of inputs, which is an important restriction.</p> <p>What about more complicated architectures? Murphy et al.<d-cite key="Janossy"></d-cite> generalise the idea of Deep Sets to applying networks to all possible \(k\)-tuples of inputs, where \(k=1\) recovers the Deep Sets case. This can be seen as unifying other architecture classes such as self-attention. However, this is not known to alleviate the constraint on the latent space mentioned above, as explained in Wagstaff et al. 2021<d-cite key="wagstaff21"></d-cite>.</p> <h2 id="approximation-vs-representation">Approximation vs. Representation</h2> <p>For simplicity, we have so far deliberately glanced over the distinction between function approximation and representation, but we will rectify this now. The Deep Sets architecture from the previous section can be written as:</p> \[\rho (\sum \phi_i(x_i))\] <p>If we forget about \(\rho\) and \(\phi\) being implemented as neural networks for a second and just think of them as general functions, it turns out that any continuous permutation invariant function can be <em>represented</em> in the above way. The word <em>represented</em> implies that it’s exact, without an approximation error, not even an arbitrarily small one. As such, Zaheer et al. 2017<d-cite key="Zaheer2017"></d-cite> and Wagstaff et al. 2019<d-cite key="wagstaff19"></d-cite> study universal function <em>representation</em>, not the softer criterion of <em>approximation</em>. However, once we assume \(\rho\) and \(\phi\) are being implemented as neural networks, it is an approximation. Hence, it makes sense to call Deep Sets a universal function <em>approximator</em> for continuous functions on sets. There is a catch here, though. If we are satisfied with approximation in the components \(\phi\) and \(\rho\), we might as well be satisfied with approximations in other places as well. A question one could ask is “how large does the latent space have to be in order to keep the errors small?”. This is unsurprisingly a much harder question to answer, but Wagstaff et al. 2021<d-cite key="wagstaff21"></d-cite> find that the result is largely the same: the latent space much have a dimensionality at least as large as the number of inputs.</p> <h2 id="what-about-graph-representation-learning">What about <em>graph</em> representation learning?</h2> <p>So, this was universality in the context of machine learning on sets, but what about graphs? Interestingly, the graph representation learning community experienced a near-identical journey, evolving entirely in parallel! Perhaps this observation comes as little surprise: to meaningfully propagate information in a graph neural network (GNN), a local, permutation invariant operation is commonplace.</p> <p>Specifically, a GNN typically operates by computing representations (<em>“messages”</em>) sent from each node to its neighbours, using a <em>message function</em><d-footnote>Here, for the purpose of clarity, we assume that the message function $\psi$ only takes into account the features of the sender and receiver nodes. It is of course possible to have additional relevant features in the graph that $\psi$ could use, for example, there could be features on the edge $i\rightarrow j$, as is often the case, e.g., in molecular graphs. Such cases can usually be resolved by inserting these features as additional inputs to $\psi$.</d-footnote>, $\psi : \mathbb{R}^k \times \mathbb{R}^k\rightarrow\mathbb{R}^l$:</p> \[\mathbf{m}_{ij} = \psi(\mathbf{x}_{i}, \mathbf{x}_{j})\] <p>where \(\mathbf{x}_{i}\) are the features of node $i$. This is followed by an <em>aggregation function</em> which, for every node, combines all of its incoming messages in a way that is invariant to permutations:</p> \[\mathbf{h}_{i} = \phi\left(\mathbf{x}_{i}, \bigoplus_{j\in\mathcal{N}_{i}} \mathbf{m}_{ji}\right)\] <p>where \(\mathcal{N}_i\) is the set of all nodes neighbouring $i$, and \(\phi : \mathbb{R}^k\times\mathbb{R}^l\rightarrow\mathbb{R}^m\) is an <em>update function</em>, updating the representation of each node \(i\) from \(\mathbf{x}_{i}\) to \(\mathbf{h}_{i}\).</p> <p>Opinions are still divided on whether <em>every</em> permutation equivariant GNN can be expressed with such pairwise messaging, with a recent position paper by Veličković<d-cite key="Velickovic22"></d-cite> claiming they <strong>can</strong>. Regardless of which way the debate goes in the future, aggregating messages over 1-hop neighbours gives rise to a highly elegant implementation of GNNs which is likely here to stay. This comes with very solid community backing, with <a href="https://www.pyg.org/" target="_blank" rel="noopener noreferrer">PyG</a>—one of the most popular GNN frameworks—<a href="https://github.com/pyg-team/pytorch_geometric/releases/tag/2.1.0" target="_blank" rel="noopener noreferrer">recently making aggregators a “first-class citizen”</a> in their GNN pipelining.</p> <p>Therefore, to build a GNN, it suffices to build a <em>permutation-invariant, local</em> layer which combines data coming from each node’s neighbours. This feels nearly identical to our previous discussion; what’s changed, really? Well, we need to take care of one seemingly minor detail: it is possible for <strong>two or more neighbours to send <em>exactly the same message</em></strong>. The theoretical framework of Deep Sets and/or Wagstaff et al. wouldn’t entirely suffice in this case, as they assumed a <em>set</em> input, whereas now we have a <em>multiset</em> (a set where some elements might be repeated)..</p> <h2 id="learning-on-graphs-and-universality">Learning on Graphs and Universality</h2> <p>Several influential GNN papers were able to overcome this limitation. The first key development came from the <em>graph isomorphism network</em> (<strong>GIN</strong>)<d-cite key="GIN"></d-cite>. GIN is an elegant example of how, over countable features, the maximally-powerful GNN<d-footnote>That is, a GNN that is capable of expressing all possible functions that can be described using several iterations of message passing between one-hop neighbours in a graph.</d-footnote> can be built up using similar ideas as in Deep Sets; so long as the local layer we use is <em>injective</em><d-footnote>Injectivity of a function means that two different inputs always yield two different outputs. In other words, if you evaluate the function twice and the output is the same both times, you know that the input must have been the same, too.</d-footnote> over multisets. Similarly to before, we must choose our encoder \(\phi\) and aggregator \(\bigoplus\), such that \(\bigoplus\limits_i \phi(x_i) \neq \bigoplus\limits_i \phi(y_i)\) unless the finite <em>multisets</em> $\{ \mkern-4mu \{x_0, x_1, …\} \mkern-4mu \}$ and $\{\mkern-4mu\{y_0, y_1, …\} \mkern-4mu \}$ are the same (\(x_i, y_i\in\mathbb{Q}\)).</p> <p>In the multiset case, the framework from Deep Sets induces an additional constraint over \(\bigoplus\)—it needs to preserve the <em>cardinality</em> information about the repeated elements in a multiset. This immediately implies that some choices of \(\bigoplus\), such as \(\max\) or averaging, will not yield maximally powerful GNNs.</p> <p>For example, consider the multisets $\{\mkern-4mu\{1, 1, 2, 2\} \mkern-4mu \}$ and $\{\mkern-4mu\{1, 2\}\mkern-4mu\}$. As we assume the features to be countable, we specify the numbers as <em>one-hot</em> integers; that is, \(1 = [1\ \ 0]\) and \(2=[0\ \ 1]\). The maximum of these features, taken over the multiset, is \([1\ \ 1]\), and their average is \(\left[\frac{1}{2}\ \ \frac{1}{2}\right]\). This is the case for both of these multisets, meaning that both maximising and averaging are <em>incapable</em> of telling them apart.</p> <p>Summations \(\left(\bigoplus=\sum\right)\), however, are an example of a suitable injective operator.</p> <p>Very similarly to the analysis from Wagstaff et al. in the domain of sets, a similar extension in the domain of graphs came through the work on <a href="**PNA**"><em>principal neighbourhood aggregation</em></a> by Corso, Cavalleri et al.<d-cite key="Corso"></d-cite>. We already discussed why it is a good idea to focus on features coming from \(\mathbb{R}\) rather than \(\mathbb{Q}\)—the universal approximation theorem only applies to functions that are continuous on \(\mathbb{R}\). However, it turns out that, when we let \(x_i, y_i\in\mathbb{R}\), it is easily possible to construct neighbourhood multisets for which setting \(\bigoplus=\sum\) would <strong>not</strong> preserve injectivity:</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/2023/assets/img/2023-05-01-sets-and-graphs/graphsuniv_examples-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/2023/assets/img/2023-05-01-sets-and-graphs/graphsuniv_examples-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/2023/assets/img/2023-05-01-sets-and-graphs/graphsuniv_examples-1400.webp"></source> <img src="/2023/assets/img/2023-05-01-sets-and-graphs/graphsuniv_examples.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>In fact, PNA itself is based on a proof that it is <em>impossible</em> to build an injective function over multisets with real-valued features using <em>any</em> <strong>single</strong> aggregator. In general, for an injective function over \(n\) neighbours, we need <em>at least</em> \(n\) aggregation functions (applied in parallel). PNA then builds an empirically powerful aggregator combination, leveraging this insight while trying to preserve numerical stability.</p> <p>Note that there is an apparent <strong>similarity</strong> between these results and the ones from Wagstaff et al. 2019<d-cite key="wagstaff19"></d-cite> . Wagstaff et al. show that, over real-valued sets of \(n\) elements, it is necessary to have an encoder representation <em>width</em> of at least \(n\). Corso, Cavalleri et al. show that, over real-valued multisets of \(n\) elements, it is necessary to aggregate them with at least \(n\) aggregators.</p> <p>There are also major differences between the two analyses: Wagstaff et al. 2019<d-cite key="wagstaff19"></d-cite> assume the sum as an aggregator, whereas Corso et al.<d-cite key="Corso"></d-cite> consider arbitrary aggregation functions. They also use different language: number of aggregators vs. dimensionality of the latent space, although the two are equivalent. Ultimately, the restriction to sums makes the sufficiency proof (the neural network <em>is</em> universal for num latents \(\geq\) num inputs) for Wagstaff et al. more complicated, which uses a sum-of-power mapping. Corso et al., on the other hand, simply use an aggregator that extracts the \(i\)th-smallest input element. The necessity proof (the neural network <em>is not</em> universal for num latents \(&lt;\) num inputs), on the other hand, is more complex for Corso et al. and uses the Borsuk–Ulam theorem, because all possible aggregation functions have to be taken into account. Remarkably, despite the different starting conditions, both proofs arrive at the exact same result: for a universal neural network, you need as many aggregators/latents as you have inputs.</p> <p>In other words, it appears that potent processing of real-valued collections necessitates representational capacity proportional to the collection’s size, in order to guarantee injectivity. Discovering this correspondence is actually what brought the two of us together to publish this blog post in the first place.</p> <p>We have now established what is necessary to create a maximally-powerful GNN over both <em>countable</em> and <em>uncountable</em> input features. So, <em>how powerful are they</em>, exactly?</p> <h2 id="the-weisfeiler-lehman-test">The Weisfeiler-Lehman Test</h2> <p>While GNNs are often a powerful tool for processing graph data in the real world, they also won’t solve <em>all</em> tasks specified on a graph accurately! As a simple counterexample, consider any NP-hard problem, such as the Travelling Salesperson Problem. If we had a fixed-depth GNN that perfectly solves such a problem, we would have shown P=NP! Expectedly, not all GNNs will be equally good at solving various problems, and we may be highly interested in characterising their <em>expressive power</em>.</p> <p>The canonical example for characterising expressive power is <em>deciding graph isomorphism</em>; that is, can our GNN distinguish two non-isomorphic graphs? Specifically, if our GNN is capable of computing graph-level representations \(\mathbf{h}_{\mathcal{G}}\), we are interested whether \(\mathbf{h}_{\mathcal{G_{1}}} \neq\mathbf{h}_{\mathcal{G_{2}}}\) for non-isomorphic graphs \(\mathcal{G}_{1}\) and \(\mathcal{G}_{2}\). If we cannot attach different representations to these two graphs, any kind of task requiring us to classify them differently is <em>hopeless</em>! This motivates assessing the power of GNNs by which graphs they are able to <em>distinguish</em>.</p> <p>A typical way in which this is formalised is by using the <em>Weisfeiler-Lehman</em> (<strong>WL</strong>) graph isomorphism test. To formalise this, we will study a popular algorithm for approximately deciding graph isomorphism.</p> <p>The WL algorithm featurises a graph \(\mathcal{G}=(\mathcal{V},\mathcal{E})\) as follows. First, we set the representation of each node \(i\in\mathcal{V}\) as \(x_i^{(0)} = 1\). Then, it proceeds as follows:</p> <ol> <li>Let $\mathcal{X}_i^{(t+1)} = \{\mkern-4mu\{x_j^{(t)} :(i,j)\in\mathcal{E}\}\mkern-4mu\}$ be the multiset of features of all neighbours of \(i\).</li> <li>Then, let \(x_i^{(t+1)}=\sum\limits_{y_j\in\mathcal{X}_i^{(t+1)}}\phi(y_j)\), where \(\phi : \mathbb{Q}\rightarrow\mathbb{Q}\) is an <em>injective</em> hash function.</li> </ol> <p>This process continues as long as the <em>histogram</em> of \(x_i^{(t)}\) changes—initially, all nodes have the same representation. As steps 1–2 are iterated, certain \(x_i^{(t)}\) values may become different. Finally, the WL test checks whether two graphs are (possibly) isomorphic by checking whether their histograms have the same (sorted) shape upon convergence.</p> <p>While remarkably simple, the WL test can accurately distinguish most graphs of real-world interest. It does have some rather painful failure modes, though; for example, it cannot distinguish a 6-cycle from two triangles!</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/2023/assets/img/2023-05-01-sets-and-graphs/graphsuniv_wlfail-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/2023/assets/img/2023-05-01-sets-and-graphs/graphsuniv_wlfail-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/2023/assets/img/2023-05-01-sets-and-graphs/graphsuniv_wlfail-1400.webp"></source> <img src="/2023/assets/img/2023-05-01-sets-and-graphs/graphsuniv_wlfail.png" class="img-fluid" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>This is because, locally, <em>all nodes look the same</em> in these two graphs, and the histogram never changes.</p> <p>The key behind the power of the WL test is the <em>injectivity</em> of the hash function \(\phi\)—it may be interpreted as assigning each node a different <em>colour</em> if it has a different <em>local context</em>. Similarly, we saw that GNNs are maximally powerful when their propagation models are <em>injective</em>. It should come as little surprise then that, in terms of distinguishing graph structures over <em>countable</em> input features, GNNs can <strong>never be more powerful than the WL test</strong>! And, in fact, this level of power is achieved <em>exactly</em> when the aggregator is injective. This fact was first discovered by Morris et al.<d-cite key="Morris"></d-cite>, and reinterpreted from the perspective of multiset aggregation by the GIN paper.</p> <p>While the WL connection has certainly spurred a vast amount of works on improving GNN expressivity, it is also worth recalling the initial assumption: \(x_i^{(0)} = 1\). That is, we assume that the input node features are <em>completely uninformative</em>! Very often, this is not a good idea! It can be proven that even placing <em>random numbers</em> in the nodes can yield to a provable improvement in expressive power (Sato et al.<d-cite key="Sato"></d-cite>). Further, many recent works (Loukas et al.<d-cite key="Loukas"></d-cite>); Kanatsoulis and Ribeiro<d-cite key="Ribeiro"></d-cite> make it very explicit that, if we allow GNNs access to “appropriate” input features, this leads to a vast improvement in their expressive power. All of these models hence surpass the 1-WL test. There is now a significant body of recent research to improve GNNs beyond the 1-WL test by giving them access to features or structures they wouldn’t otherwise be capable of computing. The broad strategies for doing so, beyond the just-discussed feature augmentation, include rewiring the graph, and explicit message passing over <em>substructures</em> in the graph. Veličković<d-cite key="Velickovic22"></d-cite> provides a bird’s eye summary of these recent developments.</p> <p>Even beyond the limitation of the uninformative input features, recent influential works (published at ICLR’22 and ‘23 as orals) have demonstrated that the WL framework itself is worth extending. Geerts and Reutter<d-cite key="Geerts"></d-cite> demonstrate clear theoretical value to expressing GNN computations using a <em>tensor language</em> (TL), allowing for drawing significant connections to <em>color refinement</em> algorithms. And Zhang et al.<d-cite key="Zhang"></d-cite> demonstrate that the WL framework may be <em>weak</em> in terms of its architectural distinguishing power, showing that many higher-order GNNs that surpass the limitations of the 1-WL test are in fact still incapable of computing many standard polynomial-time-computable properties over graphs, such as ones relating to the graph’s <em>biconnected components</em>.</p> <p>Lastly, linking back to our central discussion, we argue that focusing the theoretical analysis only on discrete features may not lead to highly learnable target mappings. From the perspective of the WL test (and basically any discrete-valued procedure), the models presented in Deep Sets and PNA are no more powerful than 1-WL. However, moving into continuous feature support, PNA is indeed more powerful at distinguishing graphs than models like GIN.</p> <h2 id="broader-context-and-takeaways">Broader Context and Takeaways</h2> <p>It is no coincidence that many of the current universality discussions within machine learning are happening inside communities that build networks that exploit symmetries (in our examples, the symmetry was always permutation invariance/equivariance, but the following argument equally applies to, e.g., rotational symmetries): exploiting symmetries with a neural network architecture is tantamount to limiting the space of functions that can be learned. This naturally raises the question of <em>how much</em> the space of learnable function has been limited. In other words: for the space of functions observing a specific symmmetry, is the neural network (still) a universal function approximator? This does not imply, however, that universality isn’t interesting in other fields, too: e.g., the fact that self-attention (popularised by natural language processing) is a universal approximator for functions on sets is an interesting property that gives its design more context. The (once) ubiquitous usage of the convolutional layer seems less surprising when knowing that it is the most general<d-footnote>In fact, it is also the only such linear layer because simpler and less expressive translation equivariant linear layers (e.g. point-wise linears) can be seen as special cases of a convolutional layer.</d-footnote> linear layer that observes translation equivariance<d-cite key="Cohen"></d-cite>.</p> <p>In this blog post, we aimed at explaining most of the key concepts of universal function approximation for set and graph-based machine learning: invariance and equivariance, sets and multisets, representation vs. approximation, injectivity, Deep Sets, GINs, WL-tests, and the motivation for universality research itself. We hope that we provided some insights into the similarities and differences of universality research on graphs and sets, and maybe even food for thought leading to future research on this intersection. We also acknowledge that this is a theoretical topic and that none of these proofs can ultimately predict how well a ‘universal’ neural network will perform on a specific task in the real world. However, even in the worst-case scenario, where theoretical universality properties are completely uncorrelated (or inversely correlated?) with real-world performance, we still hope that the thoughts and concepts of this post add a bit of additional structure to the multifaceted zoo of neural network architectures for sets and graphs.</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> </div> <d-bibliography src="/2023/assets/bibliography/2023-05-01-sets-and-graphs.bib"></d-bibliography> <d-article id="bibtex-container" class="related highlight"> For attribution in academic contexts, please cite this work as <pre id="bibtex-academic-attribution">
        PLACEHOLDER FOR ACADEMIC ATTRIBUTION
  </pre> BibTeX citation <pre id="bibtex-box">
        PLACEHOLDER FOR BIBTEX
  </pre> </d-article> <script src="https://utteranc.es/client.js" repo="iclr-blogposts/2023" issue-term="pathname" theme="github-light" crossorigin="anonymous" async> </script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> </body> </html>